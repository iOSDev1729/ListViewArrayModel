{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\fnil\fcharset0 HelveticaNeue;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red26\green28\blue31;\red255\green255\blue255;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c13725\c14902\c16078;\cssrgb\c100000\c100000\c100000;
}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
List View is nothing tabular view of a View or ViewController (UIKit). \
\
We have make out model data conforms to Identifiable Protocol \
\
What is a protocol. Why we have to confirm to it. What happens if we don't conform \
\
Protocol is nothing but a set of methods or commands or rules to be followed for completing a task. Why protocols when we have inheritance. Swift does not support multiple class inheritance. For example ,\
\
\pard\pardeftab720\sl340\partightenfactor0

\f1\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 class City \{\
    var cityId : String?\
    var cityName : String?\
\}\
\
class Town \{\
    var townid : String?\
    var townName : String?\
\
\}\
\
class Address : City , Town \{\
\
    var house : String?\
    var street: String?\
\
\}\
\
//MARK: 
\f2\fs30 \cf3 \cb4 \strokec3 Generates a compile-time error:\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 Address.swift:38:24: Multiple inheritance from classes 'City' and 'Town'\
Instead we can do as below by using protocol extensions \cb1 \
\pard\pardeftab720\sl340\partightenfactor0

\f1\fs26 \cf2 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\pard\pardeftab720\sl340\partightenfactor0

\f1\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 protocol City \{ \}\
\
extension City \{\
    var cityId: String \{\
        return "Default City ID"\
    \}\
\
    var cityName: String \{\
        return "Default City Name"\
    \}\
\
    // adding method:\
    func doSomething() \{\
        print("Do Something!!")\
    \}\
\}\
\
protocol Town \{ \}\
\
extension Town \{\
    var townid: String \{\
        return "Default Town ID"\
    \}\
\
    var townName: String \{\
        return "Default Town Name"\
    \}\
\}\
\
class Address:City, Town \{\}\
\
let address = Address() \
print(address.cityId) // Defaut City ID\
print(address.cityName) // Defaut City Name\
print(address.townid) // Default Town ID\
print(address.townName)\
\
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf3 \cb4 \strokec3 Also, if you want to add some additional job to a method,like doSomething() , we can do as below: \
\
\pard\pardeftab720\sl340\partightenfactor0

\f1\fs26 \cf2 \cb1 \strokec2 class Address:City, Town \{\
    func doSomething() \{\
        (self as City).doSomething()\
        print("Addtional Job!!")\
    \}\
\}\
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf3 \cb4 \strokec3 \
\pard\pardeftab720\sl340\partightenfactor0

\f1\fs26 \cf2 \cb1 \strokec2 let address2 = Address()\
address2.doSomething()\
// Do Something!!\
// Addtional Job!!\
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf3 \cb4 \strokec3 \
\pard\pardeftab720\sl340\partightenfactor0

\f1\fs26 \cf2 \cb1 \strokec2 Let's dissect the identifiable protocol from Apple documentation. Command + Click on Identifiable and let's dive into the code. A variety species of fishes right :P\
\
\
\
\
\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\
}